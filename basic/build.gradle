apply plugin: 'com.android.library'

android {
    compileSdkVersion 29
    buildToolsVersion "29.0.3"


    defaultConfig {
        minSdkVersion 15
        targetSdkVersion 29
        versionCode 1
        versionName "1.0"

        testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
        consumerProguardFiles 'consumer-rules.pro'
    }

    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
            //这句话就会往BuildConfig中添加数据，然后编译过后就可以在代码中获取到,app中直接BuildConfig.is_application获取
            //这句话加到哪个module，哪个module就能获取到这个属性
            //可以将这个内容放到基础模块中，这样每个引用的模块都能用到，但是这样只有当前模块能拿到，其他模块还是不能直接拿到的，所以可以在application中将这个值拿到，然后其他module从这个application拿
            buildConfigField 'boolean','is_application',rootProject.ext.app_android.is_application.toString()
        }
        advanced{
            //这句话就会往BuildConfig中添加数据，然后编译过后就可以在代码中获取到,app中直接BuildConfig.is_application获取
            //这句话加到哪个module，哪个module就能获取到这个属性
            //可以将这个内容放到基础模块中，这样每个引用的模块都能用到
            buildConfigField 'boolean','is_application',rootProject.ext.app_android.is_application.toString()
        }
        debug{
            //这句话就会往BuildConfig中添加数据，然后编译过后就可以在代码中获取到,app中直接BuildConfig.is_application获取
            //这句话加到哪个module，哪个module就能获取到这个属性
            //可以将这个内容放到基础模块中，这样每个引用的模块都能用到
            buildConfigField 'boolean','is_application',rootProject.ext.app_android.is_application.toString()
        }
    }

}

dependencies {
    implementation fileTree(dir: 'libs', include: ['*.jar'])

    implementation 'androidx.appcompat:appcompat:1.2.0'
    testImplementation 'junit:junit:4.12'
    androidTestImplementation 'androidx.test.ext:junit:1.1.2'
    androidTestImplementation 'androidx.test.espresso:espresso-core:3.3.0'

    implementation project (path: ':arouter')
}
